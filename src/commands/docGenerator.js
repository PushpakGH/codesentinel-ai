/**
 * Documentation Generator
 * Generates comprehensive documentation for selected code
 */

const vscode = require('vscode');
const path = require('path');
const { logger } = require('../utils/logger');
const aiClient = require('../services/aiClient');

/**
 * Main command - Generate documentation for selected code
 */
async function generateDocumentationCommand() {
  const editor = vscode.window.activeTextEditor;
  
  if (!editor) {
    vscode.window.showErrorMessage('❌ No active editor. Open a file first.');
    return;
  }

  const selection = editor.selection;
  const selectedText = editor.document.getText(selection);

  if (!selectedText || selectedText.trim().length === 0) {
    vscode.window.showWarningMessage('⚠️ Please select code to document');
    return;
  }

  const language = editor.document.languageId;
  const fileName = path.basename(editor.document.fileName);

  await vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'CodeSentinel',
    cancellable: false
  }, async (progress) => {
    try {
      progress.report({ message: 'Analyzing code...', increment: 20 });
      logger.info('Generating documentation:', { language, fileName, codeLength: selectedText.length });

      // Determine documentation style based on language
      const docStyle = getDocumentationStyle(language);
      
      await aiClient.initialize();

      progress.report({ message: 'Generating documentation...', increment: 40 });

      // Generate documentation
      const prompt = buildDocPrompt(selectedText, language, docStyle);

      const documentation = await aiClient.generate(prompt, {
        systemPrompt: `You are a technical documentation expert. Generate clear, comprehensive documentation following ${docStyle} style. Include descriptions, parameters, return values, and examples. Return ONLY the documentation comments, no code.`,
        maxTokens: 3000
      });

      const cleanDocs = cleanDocumentation(documentation, docStyle);

      if (!cleanDocs || cleanDocs.trim().length === 0) {
        throw new Error('Failed to generate valid documentation');
      }

      progress.report({ message: 'Inserting documentation...', increment: 30 });

      // Insert documentation above the selected code
      const insertPosition = selection.start;
      const lineAbove = editor.document.lineAt(insertPosition.line);
      const indentation = lineAbove.text.match(/^\s*/)[0];
      
      // Add proper indentation to each line of documentation
      const indentedDocs = cleanDocs.split('\n')
        .map(line => line.trim() ? indentation + line : line)
        .join('\n');

      await editor.edit(editBuilder => {
        editBuilder.insert(insertPosition, indentedDocs + '\n');
      });

      progress.report({ message: 'Done!', increment: 10 });

      vscode.window.showInformationMessage(
        '✅ Documentation generated!',
        'Format Document'
      ).then(action => {
        if (action === 'Format Document') {
          vscode.commands.executeCommand('editor.action.formatDocument');
        }
      });

      logger.info('✅ Documentation generated successfully');

    } catch (error) {
      logger.error('Documentation generation failed:', error);
      vscode.window.showErrorMessage(
        `❌ Failed: ${error.message}`,
        'View Logs'
      ).then(action => {
        if (action === 'View Logs') {
          logger.show();
        }
      });
    }
  });
}

/**
 * Determine documentation style based on language
 * @private
 */
function getDocumentationStyle(language) {
  const styleMap = {
    'javascript': 'JSDoc',
    'javascriptreact': 'JSDoc',
    'typescript': 'TSDoc',
    'typescriptreact': 'TSDoc',
    'python': 'Python Docstring (Google style)',
    'java': 'JavaDoc',
    'csharp': 'XML Documentation Comments',
    'go': 'Go Doc Comments',
    'rust': 'Rust Doc Comments',
    'php': 'PHPDoc',
    'ruby': 'RDoc/YARD',
    'swift': 'Swift Markup'
  };

  return styleMap[language] || 'Standard comments';
}

/**
 * Build documentation generation prompt
 * @private
 */
function buildDocPrompt(code, language, docStyle) {
  return `Generate ${docStyle} documentation for this ${language} code:

\`\`\`${language}
${code}
\`\`\`

Requirements:
- Use proper ${docStyle} syntax
- Include a clear description of what the code does
- Document all parameters with types and descriptions
- Document return values with types
- Add usage examples if applicable
- Mention any thrown exceptions or edge cases
- Keep it concise but complete

Return ONLY the documentation comments, without the original code.`;
}

/**
 * Clean and format documentation
 * @private
 */
/**
 * Cleans the documentation generated by the AI by removing markdown 
 * wrappers and extracting specific comment patterns.
 */
function cleanDocumentation(docs, docStyle) {
  // FIX: Added the closing / and the replacement string. 
  // This removes markdown code block markers (like ```javascript or ```)
  let cleaned = docs.replace(/```[a-z]*\n?|```/gi, '');

  // Remove any code that might have been included, keep only comment blocks
  const commentPatterns = [
    /\/\*\*[\s\S]*?\*\//g,        // JSDoc/JavaDoc style
    /"""[\s\S]*?"""/g,            // Python docstrings
    /'''[\s\S]*?'''/g,            // Python docstrings
    /\/\/\/[\s\S]*?(?=\n\n|$)/g,  // Triple slash comments
    /#[\s\S]*?(?=\n\n|$)/g        // Python/Ruby comments
  ];

  // Try to extract comment blocks
  let extracted = '';
  for (const pattern of commentPatterns) {
    const matches = cleaned.match(pattern);
    if (matches && matches.length > 0) {
      extracted = matches.join('\n\n');
      break;
    }
  }

  // If we found comment blocks, use them; otherwise use the whole cleaned text
  if (extracted) {
    cleaned = extracted;
  }

  cleaned = cleaned.trim();

  // For JSDoc/TSDoc, ensure it starts with /**
  if (docStyle && (docStyle.includes('JSDoc') || docStyle.includes('TSDoc'))) {
    if (!cleaned.startsWith('/**')) {
      if (!cleaned.startsWith('/*')) {
        cleaned = '/**\n * ' + cleaned.split('\n').join('\n * ') + '\n */';
      }
    }
  }

  return cleaned;
}

module.exports = {
  generateDocumentationCommand
};
